# CryptoZombies学习心得
[CryptoZombies官方网站](https://cryptozombies.io/en/lesson)

### 第一节课程

僵尸教程的第一节课程主要是对solidity语言的一些非常基础属性做了介绍，内容包括：

- 参数定义
- 函数的可见性
- 参数返回值和universal命名规则
- pure和view函数
- 事件

### 第二节课程
1. 僵尸教程的第二章则将重点放在——
1. 教程向我们展示了address作为用户的特征标识并将其与银行账户类比，另一个新属性mapping则是solidity语言中的一个新的数据存储结构，其中数据的存储是成对的（key and value），与其他语言的map结构是一致的，并且提供的调用方式与数组非常类似
1. contract中有require作为断言语句来控制执行情况，当判断条件为否时可以停止函数的执行。
2. 随后则是关于合约继承的public、private、external、internal之间的对比（internal为只有合约内部和子合约内部可调用的函数，external则是本合约内部无法访问，其余情况包括子合约皆可访问(在子合约内部访问父合约的external函数需要在函数前加上"this."，否则会报错)。
3. 合约和接口的定义都采用了contract关键字，区别之处在于接口内的函数没有函数体（即没有{}），直接以分号结尾
4. solidity语言的特性——多返回值，类似javasripct和python

### 第三节课程
1. 合约在部署到Ethereum之后具有不可修改性，这意味着当某一个正在使用的合约出现bug的时候，我们无法对现有的合约直接进行修改，而是只能号召用户停止使用当前合约转而使用新部署的修复版本的合约。由此可见，我们在自己的合约内设置硬编码的地址是一件风险系数非常高的事情，应采用函数来实时获取所需的地址等
2. OpenZeppelin's Ownable contract 是一个可以在DApps中使用的安全和社区审查的智能合约库，它提供合约的拥有人审查服务以限制合约的各种情况下的行为
3. 合约也拥有构造函数；Solidity语言还有Function Modifiers这种我在其他语言中未曾见过的函数（教程称之为半函数，示例modifier中用到了require，且形式非常奇异），一般用于修饰其他函数以在函数执行前检查当前的执行环境并决定是否能继续运行。示例的modifier onlyOwner()可以确保只有合约的拥有者才能访问其修饰的函数
3. Gas被成为DApps运行所需的燃料，运行的程序需要的运算资源越多，则其消耗的Gas也会越多，而gas实际上是真金白银换来的，这也就意味着这是一种限制有人恶意占用所有运算资源以使得整个网络崩溃的手段
4. 在struct中，采用更小单位的uint是可以节省storage空间的（在外部则没有区别）。同时，教程表明由于相同类型的数据会聚集，将同类对象放在临近的地方能减少空间占用（可能类似C++的内存分配）
5. 教程以“不用僵尸会拥有不用的特性”为例向我们展示了modifier的应用。个人思考修饰函数
目前看来主要的作用就是增加代码的可读性
6. Solidity语言中，对storage的修改需要消耗gas资源（因为链上相关的所有节点都要一起作出更新），而创建一个memory中储存的数组则不需要消耗运算资源，其创建需要声明长度且当前版本的Solidity下是无法更改的
7. 为了减少对Storage的更改，我们在获取一个庞大的数组中的特定所属序列的时候会采用实时遍历数组并将结果储存在内存数组中而不是将序列存在storage中

### 第四节课程
1. Solidity中提供payable修饰函数使得函数能够接受Ether（Ethereum网络中的一种货币），只有调用者在调用该函数的时候存入了相当数量的Ether的情况下函数才能被正常执行。而non-payable函数则会拒绝带有Ether的函数调用请求
2. 因为blockchain的所有数据都是对任何参与者可见的，因此要安全地生成的随机数是一件很困难的事情。教程提供的一种解决方案则是利用oracle来获取一个外部生成的随机数
3. Solidity中的if-else语句和其他函数一致

### 第五节课程
1. ERC20就是一种以太币，它的本质上是合约，换而言之一个以太币就是一个合约。以太币的添加实际上就是在数据库中增加一个新的合约地址。不过在本次实验中，用此前大火的以太猫所采用的ERC721合约来代表僵尸是一种更加合乎情理的方式。简单的区别可以概括为：ERC-721 是用来定义 Non-fungible token (非同质代币，不可替代的代币)，也就是说每个代币是 unique (唯一的)；而ERC-20中的每一个token都相同
2. Solidity语言同样支持多继承
3. 当我们采用某个标准规范来开发的时候要保证接口名称的一致性，也即是说不能去修改ERC-721合约中固有的函数名，否则合约在被调用时会引发错误
4. 教程向我们展示了合约中_transfer和approve等函数的逻辑思路，对Token的传输过程有了一个更加细致的理解。Token的两种传输方式包括：
    1. Token owner调用transferFrom，可以理解为及时传输
    2. Token owner调用approve来设置Token传输的目标地址。此后，目标地址需要Token的时候就可以调用transferFrom来获取Token，可以理解为提供传输控制权
5. Address 0被称为焚烧地址，因为没有任何人有这个地址的private key，传送进去的东西也就无法再次取出
6. OpenZeppelin为了保证数据的正确性，防止数据溢出（上溢、下溢），创造了一个名为SafeMath 的库。Solidity中的库的特性在于使用using关键字来为某种数据类型加上库中的函数方法。
7. 在SafeMath库中，我们终于看到了assert关键字。教程将assert和require的区别概括为前者用于重度崩溃级错误（如数据溢出），后者则是较轻程度的错误（如程序传入的Ether与程序设计的Ether数不符）。只有后者在程序执行失败的时候会返还gas


### 第六节课程
1. 本节课程主要内容是DApp与前端的交互，首先简单说明了Web3.js在以太坊网络节点沟通中的作用：封装JSON-RPC语言，使得我们只需要操作简单易读的JS接口
2. 介绍了提供第三方服务的Infura。它维护了一组带有缓存层的以太坊节点，用于快速读取。我们通过Infura可靠地向/从以太坊区块链发送和接收消息，而无需设置和维护自己的节点。
3. 介绍了一个提供以太账号和私有密钥管理的浏览器插件Metamask
4. 介绍了ABI（Application Binary Interface），它会以JSON格式表示合约的方法来告知Web3.js如何以合约可以理解的方式格式化函数调用
5. 展示了如何根据当前的以太账户展示账户下所拥有的僵尸（在此略过前端知识的讲述）
6. 我们可以通过两种方式来调用合约中的函数：call & send。call只能调用view和pure这些只读且不需要出块的函数，而send则是用于调用这两者之外需要消耗gas的其他函数（需要调用者address来签署交易并付出gas）。虽然他们的调用形态非常相似，但实际上是Web3.js为我们在底层做好了封装
7. 在函数中附Ether的时候需要用Ether的最小单位wei（10的18次方个wei组成一个Ether）来表明。当然Web3.js提供了两者之间的转换方法，如web3js.utils.toWei("1")会将1 ETH转换成wei
8. 在前端代码中，我们可以注册事件，当监听到事件的发生则执行某段特定的代码。为了设置事件的监听只针对指定的用户，我们可以在sol文件的事件定义中为参数加上indexed，这使得我们在前段监听的时候可以根据事件的参数进行过滤，排除不需要响应的事件
9. Web3.js提供了getPastEvents函数在给定的以太坊块号区间查询过去发生的事件，然后将这些事件展示到前端上作为另一种形式的storage


  

