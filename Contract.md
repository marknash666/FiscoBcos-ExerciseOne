# CryptoZombies学习心得
![CryptoZombies官方网站](https://cryptozombies.io/en/lesson)

### 第一节课程

僵尸教程的第一节课程主要是对solidity语言的一些非常基础的参数定义、函数的可见性、参数返回和universal命名规则、pure和view函数、事件等非常基础的元素做了一个小introduction。

### 第二节课程
1. 僵尸教程的第二章则将重点放在——
1. 教程向我们展示了address作为用户的特征标识并将其与银行账户类比，另一个新属性mapping则是solidity语言中的一个新的数据存储结构，其中数据的存储是成对的（key and value），与其他语言的map结构是一致的，并且提供的调用方式与数组非常类似。
1. contract中有require作为断言语句来控制执行情况，当判断条件为否时可以停止函数的执行。
2. 随后则是关于合约继承的public、private、external、internal之间的对比（internal为只有合约内部和子合约内部可调用的函数，external则是本合约内部无法访问，其余情况包括子合约皆可访问(在子合约内部访问父合约的external函数需要在函数前加上"this."，否则会报错)。
3. 合约和接口的定义都采用了contract关键字，区别之处在于接口内的函数没有函数体（即没有{}），以分号结尾。
4. solidity语言的特性——多返回值，类似javasripct和python

### 第三节课程
1. 合约在部署到Ethereum之后具有不可修改性，这意味着当某一个正在使用的合约出现bug的时候，我们无法对现有的合约直接进行修改，而是只能号召用户停止使用当前合约转而使用新部署的修复版本的合约。由此可见，我们在自己的合约内设置硬编码的地址是一件风险系数非常高的事情，应采用函数来实时获取所需的地址等
2. OpenZeppelin's Ownable contract 是一个可以在DApps中使用的安全和社区审查的智能合约库，它提供合约的拥有人审查服务以限制合约的各种情况下的行为
3. 合约也拥有构造函数；Solidity语言还有Function Modifiers这种我在其他语言中未曾见过的函数（教程称之为半函数，示例modifier中用到了require，且形式非常奇异），一般用于修饰其他函数以在函数执行前检查当前的执行环境并决定是否能继续运行。示例的modifier onlyOwner()可以确保只有合约的拥有者才能访问其修饰的函数
3. Gas被成为DApps运行所需的燃料，运行的程序需要的运算资源越多，则其消耗的Gas也会越多，而gas实际上是真金白银换来的，这也就意味着这是一种限制有人恶意占用所有运算资源以使得整个网络崩溃的手段
4. 在struct中，采用更小单位的uint是可以节省storage空间的（在外部则没有区别）。同时，教程表明由于相同类型的数据会聚集，将同类对象放在临近的地方能减少空间占用（可能类似C++的内存分配）
5. 教程以“不用僵尸会拥有不用的特性”为例向我们展示了modifier的应用。个人思考修饰函数
目前看来主要的作用就是增加代码的可读性
6. Solidity语言中，对storage的修改需要消耗gas资源（因为链上相关的所有节点都要一起作出更新），而创建一个memory中储存的数组则不需要消耗运算资源，其创建需要声明长度且当前版本的Solidity下是无法更改的
7. 为了减少对Storage的更改，我们在获取一个庞大的数组中的特定所属序列的时候会采用实时遍历数组并将结果储存在内存数组中而不是将序列存在storage中

### 第四节课程
1. 合约在部署到Ethereum之后具有不可修改性，这意味着当某一个正在使用的合约出现bug的时候，我们无法对现有的合约直接进行修改，而是只能号召用户停止使用当前合约转而使用新部署的修复版本的合约。由此可见，我们在自己的合约内设置硬编码的地址是一件风险系数非常高的事情，应采用函数来实时获取所需的地址等

